# FinkiQuest

## Опис на играта

Finki Quest се одвива во замислен свет од иднината, во новата модерна зграда на Факултетот за Информатички Науки и Компјутерско Инжинерство. Главен играч сте вие: студент на ФИНКИ и ваша главна цел е целта на секој студент: да дипломирате, односно да ги положите сите предмети. Finki Quest содржи 3 игри: 
- Space Algorithms
- Block Networking
- Probability Survival
  
 Секоја игра претставува предмет на факултетот што мора да биде положен за да дипломирате.  
 За да дипломирате мора да добиете барем оцена 6 во секоја од игрите.

 ##  Користени Технологии
 Finki Quest е направена со помош на Game Engine - [Godot](https://godotengine.org/) , со јазична поддршка за C#. 

 ## Содржина
 - ### Компоненти
   - [Стартно Мени](#стартно-мени)
   - [Мени за Селекција на Игри](#мени-за-селекција-на-игри)
 - ### Игри
   - [Space Algorithms](#space-algorithms)
   - [Block Networking](#block-networking)
   - [Probability Survival](#probability-survival)
  
## Space Algorithms

### Опис на играта:

Во оваа игра, играчот управува со вселенски брод кој лета низ галаксија полна со предизвици и опасности, сите инспирирани од темите на предметот "Алгоритми и Податочни Структури". Низ играта, играчот се соочува со различни типови на противници кои претставуваат концепти и проблеми од предметот Алгоритми.

### Механика на играта:

- **Противници и поени**: Играта започнува со борба против различни типови противници кои претставуваат различни концепти од предметот Алгоритми. Уништувањето на овие непријатели носи поени, со максимален износ од 40 поени.

- **Главен непријател (Испит)**: По одредено време на борење со овие непријатели, се појавува главниот непријател - Испитот. Испитот е огромен и моќен бос кој ги тестира сите вештини што играчот ги стекнал во текот на играта. За да се заврши играта успешно и да се „положи“ предметот, играчот мора да го уништи Испитот, при што се добиваат 60 поени, доволни за основна положена оценка (6).

- **Формирање на конечната оценка**: Откако ќе се победи Испитот, поените добиени од борбата со обичните противници се додаваат на конечниот резултат, формирајќи ја финалната оценка за играта (предметот). Колку повеќе поени се соберат од противниците, толку повисока ќе биде конечната оценка.

### Правила на играта:

![alt text](image.png)

### Податочни структури

Главаната игра се одвива во класата `public partial class Game : Node2D`

### `public partial class Game : Node2D`

#### Играч

Играчот претставува вселенски брод. Се движи со `WASD` или со `Arrow keys`.

```C#
Vector2 inputVector = Input.GetVector("space_algorithms_player_left", "space_algorithms_player_right", "space_algorithms_player_up", "space_algorithms_player_down");

Position += inputVector * moveSpeed * (float)delta;
```

А напаѓањето на играчот се вршти со клицк на копчето `space`

```C#
if (Input.IsActionJustPressed("space_algorithms_player_shoot")){
  Laser laser = (Laser)laserPrefab.Instantiate();
  laser.Position = Position;
  this.GetParent().AddChild(laser);
}
```

Доколку играчот е во колизија со непријател или напад на непријател тој се уништува и играта завршува

```C#
private void _on_area_entered(Area2D area){
  if(area is EnemyLaser || area is Enemy || area is Meteor || area is BossSpecial){
    QueueFree();
  }
}
```

#### Непријатели

Непријателите ги добиваат имињата на концептите од листа.
`private List<string> enemies`. При секое отчукување на тајмерот `private void _on_enemy_timer_timeout()` доколку има преостанати имиња во листата на концепти се иницијализра нов непријател на случајна позиција.

```C#
Random r = new Random();
Enemy enemy = (Enemy)enemyPrefab.Instantiate();
enemy.Position = new Vector2(_screenSize.X + 30, r.Next(40, (int)_screenSize.Y - 40));
```

потоа се додава името на концептот `enemyLabel.Text = enemies[randomIndex];`

Непријателите се уништуваат доколку детектираат колизија со ласерот на играчот па се додава поен во главната сцена.

```C#
private void _on_area_entered(Area2D area){
		if(area is Laser){
      var gameNode = (Game) this.GetParent();
			gameNode.incrementPoints();
			QueueFree();
    }
}
```

#### Испит (Boss)

Кога ќе се испразни листата се појавува Испитот.

```C#
boss = (Boss)bossPrefab.Instantiate();
boss.Position = new Vector2(_screenSize.X - 400, _screenSize.Y / 2);
this.AddChild(boss);
```

Испитот има иницијална енергија(hp) и при секоја детектирана колизија на ласер од играчот таа енергија се намалува.

```C#
private void _on_area_entered(Area2D area)
    {
        if (area is Laser)
        {
          hp--;
        }
    }
```

Престануваат да се појавуваат обичните непријатели и започнуваат специјални напади на Испитот кои се активираат со тајмери и вклучуваат: 3 ласери кои не се уништуваат, штит кој ги блокира нападите на играчот и инстанцирање на 3 метеори од кои 2 се со случајна позиција и 1 со висинка позиција на играчот кој го принудува играчот постојано да се движи или да го уништи.


## Block Networking

### Цел на играта и начин на играње

Block Networking е градена во духот на познатата игра [Tetris](https://tetris.com/play-tetris), со мал финес. Блоковите во овај тетрис се мрежни уреди и успешното завршување на играта претставува
успешно положување на предметот **Мрежи**. Во играва од играчот се очекува успешно да се справи со паѓачки блокови, кои постојано се појавуваат, дополнително играта овозможува олеснување во облик
на бришење редици полни со блокови.
Главната цел во играта е играчот да опстане одредено време (опстојување од 45s се смета доволно за оценка 6), потоа врз основа на опстанатото време играчот добива оценка, која се прикажува во посебен прозорец.
Брзината на движењата и фреквенцијата на појавувањето на блоковите се пресметуваат како функција од поминатото време, што значи дека се зголемуваат со текот на времето, што впрочем значи дека играчот 
сепак ќе треба да се потруди за повисока оценка.

Играта се игра со помош на arrow keys, притоа акциите се ивршуваат само на последниот блок во паѓање. Акциите кои се дозволени и копчината кои ги овозможуваат истите, се следниве:
+ **Up arrow** овозможува ротирање на фигурата.
+ **Left arrow** овозможува движење на фигурата за еден блок на лево.
+ **Right arrow** овозможува движење на фигурата за еден блок на десно.
+ **Down arrow** овозможува движење на фигурата за еден блок надолу.

### Oпис на соочените проблеми

Проблемите со кои се соочив во изработката на оваа игра и нивните решенија се следниве:

+ **Детектирање на стопиран блок и правилно движење на блоковите**. Пред било какво движење на блок потребно да е осигураме дека:

	+ **Новата позиција не излегува од екранот**. Овај услов го проверувам во А1,А2,Б1. Променливата `isDownMove` е битна заради тоа што сакаме во играта само при надолно движење, блокот да се фиксира, односно да стани
	  неподвижен. Променливата `positions` е листа на новите, недоделени позиции, односно позиции за проверка. `UpdateCount()` е функција која го ажурира `CountByRow`(потребата од променливата е објаснета подолу за проблемот "Оптимално пратење на пополнетоста на редиците" ), заради тоа што блокот станал фиксен, на местата каде што се користи `UpdateCount()` и според тоа потребно е промената да се евидентира.

	+ **Новата позиција не е окупирана од некој друг блок**. Овај услов го проверувам во Б2, со што се проверува дали на новата позиција `SharedBitMap[x, y]` има веќе блок и дали се на различни групи.
	  Проверката дали блокојте се на различни групи е важно за да не ги погрешиме претходните позиции на блоковите од истата група со новите позициите на истите, бидејќи блокојте од иста група се движат заедно.

```C#
 private bool CanMove(List<Vector2> positions, bool isDownMove)
	{
		var rowNum = FinkiTetrisPlayingGame.Dimensions.Item1;
		var columnNum = FinkiTetrisPlayingGame.Dimensions.Item2;

		foreach (var pos in positions)
		{
			var x = (int)pos.X;
			var y = (int)pos.Y;
			
			//А1 
			if (x >= rowNum && !isDownMove)
			{
				return false;
			}
		
			//А2
			if (x >= rowNum && isDownMove)
			{
				IsStopped = true;
				UpdateCount();
				return false;
			}
			
			//Б1
			if (y < 0 || y >= columnNum)
			{
				return false;
			}
			
			//Б2
			if (SharedBitMap[x, y] is not null && SharedBitMap[x, y].Parent != this)
			{
				if (isDownMove)
				{
					IsStopped = true;
					UpdateCount();
				}

				return false;
			}
		}

		return true;
	}
```
+ **Пратење на позицијата на блоковите**. За решавање на овај проблем користам матрица со фиксна големина од 20x10 (`BitMap` во `BlockNetworkingPlaying`), која постојано мора да ја рефлектира состојбата на екранот. Ажурирањето на матрицата е оставено на индивидуалните блокови (инстаци од `Block` класата), кои при секое поместување или ротирање вршат промени на оваа структура. Се одлучив за користење
  на оваа структура заради тоа што многу брзо и лесно можам да добијам кој е блокот во дадена ќелија, исто така и која е групата во која припаѓа блокот(групата е претставена преку `Parent`)

+ **Оптимално пратење на пополнетоста на редиците**. Со цел избегнување на постојаното O(n^2) време потребно да се провери целата матрица за целосно пополнета редица, ja користам низа `CountByRow`, чија намена е постојано да го прати бројот на неподвижни блокови во редиците. Нејзиното ажурирање, исто како и за`BitMap` структурата, е оставено на самите блокови.

+ **Ротирање на групите од блокови**. Секој тип на група е претставен со интерфејсот `IGroupTypes` и неговите имплементации. Позициите на индивидуалните блокови се претставени преку distance вектори од некоја пивот позиција, тоа ми овозможи само преку една точка на екранот да ја конструирам целата група. Во пивот точката може да замислиме дека има две оски x,y чии насоки се променливи.
  Користењето на оските ни овозможува ротацијата да ја извршиме со смена на насоките на оските. На пр. ако пивот точка ни е (0,0) и имаме блок со distance вектор од таа точка (0,1), тоа значи дека во неротирана состојба (кога x oската има насока (1,0) и y оската има насока (0,-1))
  блокот би се наоѓал над пивот точката((0,0) + 0*(1,0)+1*(0,-1)=(0,-1)). За да ја ротираме групата за 90 степени само ги ротираме оските за 90 степени што значи дека x оската би имала насока (0,1) и y оската би имала насока (1,0). Сега ако се обидиме да ја издрадиме групата би добиле дека (0,0)+1*(1,0)+0*(0,-1)=(1,0),односно блокот би се наоѓал десно од пивот точката. Во имплементацијата `pivotPosition` ја содржи позицијата на пивот точката(склаирана во `Block` матрицата), `fromPivotToBlcok` се distance векторите на сите блокови во тој тип на група и `direction` ги содржи насоките
  на оските, од кои зависи самата ротација.

```C#
public static List<Vector2> FindBlocksBitmapPosition(Vector2 pivotPosition, Vector2[] fromPivotToBlcok,
		(Vector2, Vector2) direction)
	{
		List<Vector2> newPositions = new List<Vector2>(fromPivotToBlcok.Length); 
		newPositions.Add(pivotPosition);

		for (int i = 1; i < fromPivotToBlcok.Length; i++)
		{
			var newPosition = new Vector2(pivotPosition.X, pivotPosition.Y);

			var currentDisFromPivot = fromPivotToBlcok[i];

			var xAxis = direction.Item1;
			var yAxis = direction.Item2;

			var xAxisTranslation = new Vector2(currentDisFromPivot.X * xAxis.X, currentDisFromPivot.X * xAxis.Y);
			var yAxisTranslation = new Vector2(currentDisFromPivot.Y * yAxis.X, currentDisFromPivot.Y * yAxis.Y);
			
			newPosition.X += xAxisTranslation.X + yAxisTranslation.X;
			newPosition.Y += xAxisTranslation.Y + yAxisTranslation.Y;
			
			newPositions.Add(newPosition);
		}

		return newPositions;
	}
```

+ **Анимации за бришење и падвење**. Секоја интеркација со тајмер, тајмерите се потребни за синхронизација и извршување на анимациите
  (Godot ни овозможува анимациите да ги реализираме преку нодојте од типот `AnimationPlayer`, но ако истите ги искористев во проблемот, тогаш за секој блок на екранот ќе имав посебен `AnimationPlayer` и
  истото би имало големи последици на преформасите) се реализира преку интеркација со инстанца од класата `TimerMenager`. Целта на `TimerMenager` е полесно координирање на низа на акции во однос на повеќе тајмери,
  истите се потребни како на пр. за замрзнување на екранот при бришење на блокови, каде што потребно е `_timerTracker`,`_spawnTimer`,`MoveTimer` да се запрат. Класата овозможува избегнување на проблеми од типот на "Заборавив да го исклучам тајмер за движење во еднава функција" или пак "Заборавив да го активирам тајмерот за инстанцирање во другава функција".

### Слики од играта 

+ **Почетен прозорец**

![](/BasicNetworking/README_Assets/BasicNetworkingIntro.png)

+ **Прозорец за играње** 


## Probability Survival

Оваа игра ја прати тематиката на Endless Survival - тип на игри во кои што целта е да се преживее што подолго.  
Играчот е постојано бркан од непријатели, чија цел е да го убијат. Непријателите се појавуваат во бранови, каде секој бран трае 30 секунди.   

Што повеќе време помиува во еден бран, толку почесто се појавуваат непријатели, и што повеќе бранови поминуваат, непријателите стануваат се` посилни и се појавуваат нови типови на непријатели.  
Играчот, со убивање на непријатели паѓаат парички кои носат поени. Од поените зависи оценката прикажана во горниот лев агол на екранот. Играчот добива оценка доволна за положување кога ќе стекне барем 500 поени. Потоа се добиваат повисоки оценки се до 1200 поени.  

Играта завршува кога играчот ќе умре или ако се напушти играта. Може да се игра произволен број на пати со цел да си ги подобрите поените и оценката.

Правилата на играта се опишани пред да почнете:

![image](https://github.com/user-attachments/assets/987d17b0-64f2-48c1-b07d-ef7f20d80a6f)




### Функционалности


#### Играч

Играчот го движите со WASD копчињата и напаѓате со лев клик на глувчето.   
Секој напад е уникатен, така што има различна брзина на напаѓање и сила на напад.  
Бирате напади со притискање на R копчето, со секое притискање се бира следниот напад.  
Играчот има вкупно 3 напади, но сите не се достапни од почеток.  
  - Првиот напад го добивате веднаш, при почеток на играта
  - Вториот напад го добивате на вториот бран
  - Третиот напад го добивате на четвртиот бран

  Движењето на играчот се следи така што се пратат Input настани во секоја рамка од играта и се составува Vector2 според притиснатите копчиња, па се нормализира. Така ја добиваме насоката на движење. 
  
  ```C#
  Vector2 direction = Input.GetVector(
                  "FINKISURVIVE_player_left", 
                  "FINKISURVIVE_player_right", 
                  "FINKISURVIVE_player_up", 
                  "FINKISURVIVE_player_down").Normalized();
  ```


  Вака со притискање на две копчиња заедно (пример W и D), играчот може да се движи и дијагонално, односно во 8 насоки. 
  При движење, играчот ја прати позицијата на глувчето, т.е насоката. Со помош на анимации играчот се врти во насока на глувчето.

#### Непријатели

Непријателите функционираат така што се појавуваат во случајни позиции во однос на играчот. Од кога ќе се појават, тие имаат информација за позицијата на играчот, и постојано се движат кон него, со цел да го убијат. Кога ќе се доближат доволно блиску, ја повикуваат својата анимација за напад па го напаѓаат играчот.
Засега има 3 типа на непријатели: OrcMob,ZombieMob и KnightMob. Секој непријател наследува од абстрактна класа Mob од каде што ги добива основните функционалности, па потоа си имплементира свои специфични функционалности како силата и брзината на неговиот напад, како и брзината на движење.
```C#

public abstract void Attack();

//Имплементација во OrcMob:

public override void Attack()
		{
			if (!CanAttack) return;
			GetNode<Player>("/root/Level/Player").TakeDamage(GetDamage());
			_animSprite.Play("attack");
			CanAttack = false;
			
		}

```



#### Напади


## Стартно Мени

## Мени за Селекција на Игри
